## 原理

为什么需要GC?

内存资源的有限性，不可能每次都创建实例。



## 引用计数

 循环依赖导致引用成还，永远不会被清除。

在java中,引用和对象是有关联的.如果需要需要操作对象,就必须用引用进行.因此,很显然一个简单的办法是通过引用计数来判断一个对象是否可以被回收
简单说就是一个对象没有任何与之关联的引用,即他们的引用计数不为0,则说明对象不太可能再被用到,那么这个对象就是可回收对象.



## 可达性分析

为了解决引用计数法循环引用的问题,java使用了可达性分析的方法.通过一系列的"GC roots"对象作为起点搜索.如果在"GC roots"和一个对象之间没有可达路径,则称该对象是不可达的.

注意:不可达对象 != 可回收对象.  不可达对象变为可回收对象至少要经过两次标记过程.两次标记后仍然是可回收对象,则将面临回收.

## 标记清除算法（mark and sweep）

* 标记所有可达对象，并在本地内存中native分别记下
* 清除不可达对象。保证内存分配时候可以用
* 进行压缩，对内存进行整理，减少内存碎片



### 优势

1. 处理循环依赖
2. 只扫描部分对象



## 分代假设



## GCRoot

1. 当前正在执行方法的局部变量和输入参数
2. 活动线程
3. 所有类的静态字段
4. JNI引用



## 串行Gc

-XX: +UseSerialGC



对年轻代使用mark-copy 标记-复制算法，对老年代使用mark-sweep-compact(标记-清除-整理算法)。两者都是单线程的不能并行处理，都会stw.不猛充分利用多核Cpu



-XX:+UseParNew: 改进版本的Serial Gc,可以配合Cms使用



## 并行GC

Java 8 默认使用的

Java 9之后使用G1 GC

也是对年轻代使用mark-copy 标记-复制算法，对老年代使用mark-sweep-compact(标记-清除-整理算法)。

-xx:+UseParallelGC

-xx:+UseParalleOldlGC

-xx:ParallelGCThread=N指定GC线程数，默认值为cpu核心数



默认使用所有线程，需要stw停掉业务线程



## CMSGC最大可能性并发清除算法

对年轻代采用并行Stw方式的mark-copy算法，对老年代使用并发mark-sweep算法

为了避免老年代收集垃圾时候产生卡顿，主要通过两种方法来达成

1. 不对老年代进行整理，而是使用空闲列表
2. 标记清除阶段的大部分工作和应用线程一起并发执行

Cms使用的并发线程数等于核心数的1/4

可以和业务线程并发执行，GC 暂停时间少



不需要停业务线程

Cms GC 的六个阶段

1. Initial Mark 初始化标记  stw
2. Concurrent Mark 并发标记 stw
3. Concurrent Preclean 并发预清理 stw
4. Final Remark 最终标记 stw
5. Concurrent Sweep 并发清除
6. Concurrent Reset 并发重置



## G1 GC

Garbage first

* 垃圾优先，那一块的垃圾最多就清理哪一块
* 不再分年轻代老年代，而是分多个小块（2048）Region,每个小块可能被定义为Eden区一会被定义为Suvivor或者old 区

命令：

-xx:+UseG1GC -xx:MaxGCPauseMills=50



# 验证总结

首先需要提到的一点是 GC 的时间和存活的对象数量有关，和堆内存的大小关系没有那么大。

 

配置堆内存 512M，YGC 后年轻代存活对象大概 20M。

- **串行 GC** 利用单线程执行，GC 暂停的时间明显会比较长。在实际的测试下，在小堆内存空间的情况下，YGC 和并行 GC 的 YGC 差不多。FGC 使用的时间明显较长，**大概是并行 GC 的一倍（存活对象 300M 左右）**。老年代存活对象占用的空间大，整理移动的时间就长。
- CMS GC 的老年代清理明显的暂停时间降低。在 GC 日志中有发现 concurrent mode failure 的情况。查询资料后明白，CMS 在 cleanup 是并发执行的，这时的对象引用关系发生改变，也可能有新的对象需要分配空间。如果没有预留足够的空间内存分配就会导致并发失败。可能重新 CMS ，或者 GC 退化成 Serial。
- G1 GC 出现了 Humongous Allocation 因为大对象分配失败，触发了 initial-mark。也是重新标记，或者 GC 退化的问题。

 

堆内存越大，内存中可容纳的对象越多，GC 的次数随之减少，单次 GC 的暂停时间可能更长（取决于存活对象的数量）。

 

总的来说，注意不同 GC 策略采用的算法，以及设计的目的。比如 CMS 在于并发执行，提高系统响应。Parallel 更倾向于提高吞吐量；G1 GC 倾向于可配置可预估的暂停时间。

 

CMS - 老年代 没有整理，使用 free-list 管理回收内存；真正的 STW 时间小，但是步骤多，还有浮动垃圾，GC 退化问题。G1 GC 也存在 GC 退化问题。

 

配置堆内存的时候，注意 JVM 自身需要的内存和系统需要的内存，预留一定的空间。

-Xms -Xmx 直接一步到位，扩容的时候有性能的抖动。

年轻代和老年代的比例默认 1:2，新生代:from:to = 8：1：1，根据情况来调整。

根据对象晋升回收速率的计算，进行空间，晋升年龄的配置。